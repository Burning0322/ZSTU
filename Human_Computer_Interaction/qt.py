import sys
from PyQt5.QtWidgets import QApplication, QMainWindow
from PyQt5.QtCore import QTimer
from PyQt5 import QtWidgets
from MainWindow import Ui_MainWindow  # Replace YourGeneratedFile with the actual module name
import os
import django

# 设置DJANGO_SETTINGS_MODULE环境变量
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "Human_Computer_Interaction.settings")

# 初始化Django
django.setup()

class MainWindow(QMainWindow, Ui_MainWindow):
    def __init__(self):
        super().__init__()
        self.setupUi(self)  # This method is generated by pyuic5
        self.populate_comboboxes()

        # Connect the save button click signal to the corresponding methods
        self.pushButton.clicked.connect(self.save_reactor_model)
        self.pushButton_7.clicked.connect(self.save_task)
        self.pushButton_10.clicked.connect(self.save_trunk_type)
        self.pushButton_12.clicked.connect(self.save_dknowledge)
        self.pushButton_14.clicked.connect(self.save_pknowledge)
        self.pushButton_16.clicked.connect(self.save_cognitivemodel)

        # Connect the 查询 button click signal to the corresponding method
        self.pushButton_17.clicked.connect(self.query_cognitivemodel)

        # Create a timer for automatic updates (every 5000 milliseconds)
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.update_comboboxes)
        self.timer.start(5000)  # Adjust the interval as needed

        # Connect the exit button click signal to the close method
        self.pushButton_2.clicked.connect(self.close)
        self.pushButton_8.clicked.connect(self.close)
        self.pushButton_9.clicked.connect(self.close)
        self.pushButton_11.clicked.connect(self.close)
        self.pushButton_13.clicked.connect(self.close)
        self.pushButton_15.clicked.connect(self.close)

        #Set the first page to be displayed
        self.show_first_page()

    def show_first_page(self):
        # Set the active tab to the first page (index 0)
        self.tabWidget.setCurrentIndex(0)

    def save_reactor_model(self):
        from coper.models import ReactorModel

        # Get the title and description from the text fields
        title = self.textEdit.toPlainText()
        description = self.textEdit_2.toPlainText()

        # Check if the title is empty
        if not title.strip():
            QtWidgets.QMessageBox.warning(self, "Error", "Reactor_model cannot be empty.")
            self.clear_input_fields()
            return  # Stop execution if title is empty

        # Create the ReactorModel instance and save it
        reactor_model = ReactorModel(title=title, description=description)
        reactor_model.save()

        # Show success message
        QtWidgets.QMessageBox.information(self, "Success", "Reactor Model information saved successfully.")

        # Clear input fields
        self.clear_input_fields()

    def save_task(self):
        from coper.models import Task  # Import inside the method

        # Retrieve the title and description
        title = self.textEdit_10.toPlainText()
        description = self.textEdit_9.toPlainText()

        # Check if the title is empty
        if not title:
            QtWidgets.QMessageBox.warning(self, "Error", "Task_name cannot be empty.")
            self.clear_input_fields()
            return  # Stop the method if the title is empty

        # Create a Task object
        task = Task(title=title, description=description)

        # Save the Task if the title is not empty
        task.save()

        # Show a success message
        QtWidgets.QMessageBox.information(self, "Success", "Task information saved successfully.")

        # Clear input fields
        self.clear_input_fields()

    def save_trunk_type(self):
        from coper.models import TrunkType  # Import inside the method
        title = self.textEdit_12.toPlainText()
        description = self.textEdit_11.toPlainText()

        # Check if the title is empty
        if not title.strip():
            QtWidgets.QMessageBox.warning(self, "Error", "Trunk_type cannot be empty.")
            self.clear_input_fields()
            return  # Return without saving if the title is empty

        trunk_type = TrunkType(title=title, description=description)
        trunk_type.save()

        QtWidgets.QMessageBox.information(self, "Success", "Trunk Type information saved successfully.")
        self.clear_input_fields()

    def save_dknowledge(self):
        from coper.models import ReactorModel, Task, TrunkType, DKnowledge

        title = self.textEdit_14.toPlainText()
        description = self.textEdit_13.toPlainText()

        # Check if title or description is empty
        if not title or not description:
            QtWidgets.QMessageBox.warning(self, "Error", "Title and Description cannot be empty.")
            self.clear_input_fields()
            return

        # Retrieve selected items from combo boxes
        reactor_model_title = self.comboBox.currentText()
        task_title = self.comboBox_2.currentText()
        trunk_type_title = self.comboBox_3.currentText()

        reactormodel = ReactorModel.objects.get(title=reactor_model_title)
        task = Task.objects.get(title=task_title)
        trunktype = TrunkType.objects.get(title=trunk_type_title)

        dknowledge = DKnowledge(
            title=title,
            description=description,
            reactormodel=reactormodel,
            task=task,
            trunktype=trunktype,
        )
        dknowledge.save()

        QtWidgets.QMessageBox.information(self, "Success", "DKnowledge information saved successfully.")
        self.clear_input_fields()

    def save_pknowledge(self):
        from coper.models import PKnowledge  # Import inside the method
        condition = self.textEdit_5.toPlainText()
        outcome = self.textEdit_6.toPlainText()

        # Check if condition and outcome are not empty
        if not condition or not outcome:
            QtWidgets.QMessageBox.warning(self, "Error", "Condition and Outcome cannot be empty.")
            self.clear_input_fields()
            return

        pknowledge = PKnowledge(condition=condition, outcome=outcome)
        pknowledge.save()

        QtWidgets.QMessageBox.information(self, "Success", "PKnowledge information saved successfully.")
        self.clear_input_fields()

    def save_cognitivemodel(self):
        from coper.models import PKnowledge, CognitiveModel

        name = self.textEdit_15.toPlainText()
        author = self.textEdit_16.toPlainText()
        task_name = self.textEdit_17.toPlainText()
        description = self.textEdit_18.toPlainText()

        # Check if name, author, and taskname are empty
        if not name or not author or not task_name:
            QtWidgets.QMessageBox.warning(self, "Error", "Name, Author, and Task Name cannot be empty.")
            self.clear_input_fields()
            return

        # Retrieve selected items from combo boxes
        pknowledge_pk = self.comboBox_4.currentData()

        # Get the PKnowledge object using the primary key
        pknowledge = PKnowledge.objects.get(pk=pknowledge_pk)

        # Save the new CognitiveModel
        cognitivemodel = CognitiveModel(
            name=name,
            author=author,
            taskname=task_name,
            description=description,
        )
        cognitivemodel.save()

        # Add the selected PKnowledge to the ManyToManyField
        cognitivemodel.production.add(pknowledge)

        QtWidgets.QMessageBox.information(self, "Success", "Cognitivemodel information saved successfully.")
        self.clear_input_fields()

    def clear_input_fields(self):
        # Clear the content of the text fields
        self.textEdit.clear()
        self.textEdit_2.clear()
        self.textEdit_10.clear()
        self.textEdit_9.clear()
        self.textEdit_12.clear()
        self.textEdit_11.clear()
        self.textEdit_14.clear()
        self.textEdit_13.clear()
        self.textEdit_18.clear()
        self.textEdit_5.clear()
        self.textEdit_6.clear()
        self.textEdit_15.clear()
        self.textEdit_16.clear()
        self.textEdit_17.clear()

    def populate_comboboxes(self):
        # Assuming self.comboBox, self.comboBox_2, and self.comboBox_3 are your combo boxes
        self.populate_reactor_models_combobox()
        self.populate_tasks_combobox()
        self.populate_trunk_types_combobox()
        self.populate_pknowledge_combobox()

    def populate_reactor_models_combobox(self):
        from coper.models import ReactorModel

        # Clear existing items
        self.comboBox.clear()

        # Retrieve ReactorModel objects from the database
        reactor_models = ReactorModel.objects.all()

        # Add items to the combo box
        for model in reactor_models:
            item_text = model.title
            item_data = model.pk
            self.comboBox.addItem(item_text, item_data)

    def populate_tasks_combobox(self):
        from coper.models import Task

        # Clear existing items
        self.comboBox_2.clear()

        # Retrieve Task objects from the database
        tasks = Task.objects.all()

        # Add items to the combo box
        for task in tasks:
            item_text = task.title
            item_data = task.pk
            self.comboBox_2.addItem(item_text, item_data)

    def populate_trunk_types_combobox(self):
        from coper.models import TrunkType

        # Clear existing items
        self.comboBox_3.clear()

        # Retrieve TrunkType objects from the database
        trunk_types = TrunkType.objects.all()

        # Add items to the combo box
        for trunk_type in trunk_types:
            item_text = trunk_type.title
            self.comboBox_3.addItem(item_text)

    def populate_pknowledge_combobox(self):
        from coper.models import PKnowledge

        # Clear existing items
        self.comboBox_4.clear()

        # Retrieve PKnowledge objects from the database
        pknowledges = PKnowledge.objects.all()

        # Add items to the combo box
        for pknowledge in pknowledges:
            display_text = f"{pknowledge.condition} => {pknowledge.outcome}"
            self.comboBox_4.addItem(display_text, pknowledge.pk)

    def query_cognitivemodel(self):
        from coper.models import CognitiveModel, DKnowledge

        # Retrieve selected items from combo boxes
        cognitivemodel_description = self.comboBox_4.currentText()

        # Get the list of DKnowledge objects with a matching description
        matching_dknowledges = DKnowledge.objects.filter(description=cognitivemodel_description)

        # If there are matching DKnowledge objects, display their titles in the cognitivemodel's description
        if matching_dknowledges:
            titles = [dknowledge.title for dknowledge in matching_dknowledges]
            description_text = ", ".join(titles)
            self.textEdit_18.setPlainText(description_text)
        else:
            self.textEdit_18.setPlainText("")
            QtWidgets.QMessageBox.information(self, "Query Result", "No matching DKnowledge found.")

    def update_comboboxes(self):
        # Update the items in the combo boxes
        self.populate_reactor_models_combobox()
        self.populate_tasks_combobox()
        self.populate_trunk_types_combobox()
        self.populate_pknowledge_combobox()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    mainWindow = MainWindow()
    mainWindow.show()
    sys.exit(app.exec_())
